{- -----------------------------------------------------------------------------

(c) The GHC Team, 1992-2012
(c) William Kenyon, 2014

DeriveConstants is a program that extracts constants from the C
declarations in the header files (primarily struct sizes and field offsets)
and makes these constants availiable to Haskell and Cmm files.

Many struct sizes and field offsets depend on the CPP defines PROFILING
and TABLES_NEXT_TO_CODE. Therefore, DerivedConstants generates 4 sets of
constants, with the following set of CPP defines:
[] [Profiling] [TablesNextToCode] [Profiling,TablesNextToCode]

To add a new derived constant:                     go to [Add constant]
To add sensitivity to a new CPP define e.g. DEBUG: go to [Add sensitivity]
------------------------------------------------------------------------------ -}

import Control.Monad
import Data.Bits
import Data.Char
import Data.List
import Data.Map (Map)
import Data.Set (Set)
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Maybe
import Numeric
import System.Environment
import System.Exit
import System.FilePath
import System.IO
import System.Info
import System.Process

{-
--------------------
-- [Add constant] --
--------------------

 1. Is your new constant is sensitive to either of the CPP defines
    PROFILING or TABLES_NEXT_TO_CODE?
    Add your constant below the appropriate line:
      [Sensitive to []]
      [Sensitive to [Profiling]]
      [Sensitive to [Profiling,TablesNextToCode]]

    If you are unsure, add your constant below the [Sensitive to []] line.
    The sanityCheck ([Note sanityCheck]) function will error at runtime if
    you were wrong.

 2. What sort of constant would you like to generate?
      - size [Cmm] "StgClosure"
        generates a SIZEOF_StgClosure definition that can be used in Cmm files

      - size [Haskell] "StgClosure"
        generates a sIZEOF_StgClosure function that can be used in haskell files

      - size both "StgClosure"
        generates both of the above

      - offset [...] "StgClosure" "info"
        can generate several different different constants, explained in the
        following table:
        +----+----------------+--------------------------------------+
        |    |                | Example, constant generated by:      |
        | x  | Description    | offset x "StgClosure" "info"         |
        +====+================+======================================+
        | co | Cmm offset     | OFFSET_StgClosure_info               |
        | ho | Haskell offset | oFFSET_StgClosure_info               |
        | bo | Both offset    | both of the above                    |
        +----+----------------+--------------------------------------+
        | cr | Cmm rep        | REP_StgClosure_info                  |
        | hr | Haskell rep    | rEP_StgClosure_info                  |
        | br | Both rep       | both of the above                    |
        +----+----------------+--------------------------------------+
        | cm | Cmm macro      | StgClosure_info(__ptr__)             |
        | hm | Haskell macro  | lOAD_StgClosure_info                 |
        |    |                | sTORE_StgClosure_info                |
        | bm | Both macro     | all three of the above               |
        +----+----------------+--------------------------------------+

        This table is not quite complete, there are some other lesser
        used offset functions, such as bro, cro, and hro for generating
        relative offsets. See [Note Relative offsets]

-}

constants :: [Constant]
constants =
  -----------------------
  -- [Sensitive to []] --
  -----------------------
  map (mkSensitiveTo []) (concat
  [[mkWord both  "BLOCK_SIZE"         "BLOCK_SIZE"]
   -- Size of a storage manager block (in bytes).
  ,[mkWord [Cmm] "MBLOCK_SIZE"        "MBLOCK_SIZE"]
  -- blocks that fit in an MBlock, leaving space for the block descriptors
  ,[mkWord both  "BLOCKS_PER_MBLOCK" "BLOCKS_PER_MBLOCK"]

   ---------------------------------------------------------------------
   -- [Note Relative offsets]                                         --
   -- Sometimes struct fields are not accessed from the start of the  --
   -- struct                                                          --
   --                                                                 --
   -- Consider:                                                       --
   -- typedef struct Capability_ {                                    --
   --   StgFunTable f;                                                --
   --   StgRegTable r;                                                --
   --   ...                                                           --
   -- } Capability                                                    --
   --                                                                 --
   -- The stg register BaseReg points to cap.r (where cap is some Capability)
   -- BaseReg is also used to access fields in cap.f using a relative offset
   -- from cap.r                                                      --
   --                                                                 --
   --               Capability                                        --
   -- StgFunTable  +-------------------------+                        --
   --              | f.stgEagerBlackholeInfo |                        --
   --              +-------------------------+                        --
   --              | f.stgGCEnter1           |                        --
   --              +-------------------------+                        --
   --              | f.stgGCFun              |                        --
   -- StgRegTable  +=========================+ <--- BaseReg           --
   --              | r.rR1                   |                        --
   --              +-------------------------+                        --
   --              | r.rR2                   |                        --
   --              +-------------------------+                        --
   --              | r.rR3                   |                        --
   --              +-------------------------+                        --
   --              | ...                     |                        --
   --              | ...                     |                        --
   --                                                                 --
   -- The bro, cro, hro functions can generate these relative offsets --
   ---------------------------------------------------------------------

  -- Note: [Relative offsets]
  ,offset [bro "r"] "Capability" "f.stgEagerBlackholeInfo" -- < -3 Words
  ,offset [bro "r"] "Capability" "f.stgGCEnter1" -- <-- BaseReg -2 Words
  ,offset [bro "r"] "Capability" "f.stgGCFun"    -- <-- BaseReg -1 Word
  ,offset [bo] "StgRegTable" "rR1"               -- <-- BaseReg
  ,offset [bo] "StgRegTable" "rR2"               -- <-- BaseReg +1 Word
  ,offset [bo] "StgRegTable" "rR3"               -- <-- BaseReg +2 Words
  ,offset [bo] "StgRegTable" "rR4"               -- <-- ...
  ,offset [bo] "StgRegTable" "rR5"
  ,offset [bo] "StgRegTable" "rR6"
  ,offset [bo] "StgRegTable" "rR7"
  ,offset [bo] "StgRegTable" "rR8"
  ,offset [bo] "StgRegTable" "rR9"
  ,offset [bo] "StgRegTable" "rR10"
  ,offset [bo] "StgRegTable" "rF1"
  ,offset [bo] "StgRegTable" "rF2"
  ,offset [bo] "StgRegTable" "rF3"
  ,offset [bo] "StgRegTable" "rF4"
  ,offset [bo] "StgRegTable" "rF5"
  ,offset [bo] "StgRegTable" "rF6"
  ,offset [bo] "StgRegTable" "rD1"
  ,offset [bo] "StgRegTable" "rD2"
  ,offset [bo] "StgRegTable" "rD3"
  ,offset [bo] "StgRegTable" "rD4"
  ,offset [bo] "StgRegTable" "rD5"
  ,offset [bo] "StgRegTable" "rD6"
  ,offset [bo] "StgRegTable" "rXMM1"
  ,offset [bo] "StgRegTable" "rXMM2"
  ,offset [bo] "StgRegTable" "rXMM3"
  ,offset [bo] "StgRegTable" "rXMM4"
  ,offset [bo] "StgRegTable" "rXMM5"
  ,offset [bo] "StgRegTable" "rXMM6"
  ,offset [bo] "StgRegTable" "rYMM1"
  ,offset [bo] "StgRegTable" "rYMM2"
  ,offset [bo] "StgRegTable" "rYMM3"
  ,offset [bo] "StgRegTable" "rYMM4"
  ,offset [bo] "StgRegTable" "rYMM5"
  ,offset [bo] "StgRegTable" "rYMM6"
  ,offset [bo] "StgRegTable" "rZMM1"
  ,offset [bo] "StgRegTable" "rZMM2"
  ,offset [bo] "StgRegTable" "rZMM3"
  ,offset [bo] "StgRegTable" "rZMM4"
  ,offset [bo] "StgRegTable" "rZMM5"
  ,offset [bo] "StgRegTable" "rZMM6"
  ,offset [bo] "StgRegTable" "rL1"
  ,offset [bo] "StgRegTable" "rSp"
  ,offset [bo] "StgRegTable" "rSpLim"
  ,offset [bo] "StgRegTable" "rHp"
  ,offset [bo] "StgRegTable" "rHpLim"
  ,offset [bo] "StgRegTable" "rCCCS"
  ,offset [bo] "StgRegTable" "rCurrentTSO"
  ,offset [bo] "StgRegTable" "rCurrentNursery"
  ,offset [bo] "StgRegTable" "rHpAlloc"
  ,offset [co,cr,cm] "StgRegTable" "rRet"
  ,offset [co,cr,cm] "StgRegTable" "rNursery"

  ,offset [bo]       "Capability"  "r"
  ,offset [co]       "Capability"  "lock"
  ,offset [co,cr,cm] "Capability"  "no"
  ,offset [co,cr,cm] "Capability"  "mut_lists"
  ,offset [co,cr,cm] "Capability"  "context_switch"
  ,offset [co,cr,cm] "Capability"  "interrupt"
  ,offset [co,cr,cm] "Capability"  "sparks"

  ,offset [bo,br,bm] "bdescr"      "start"
  ,offset [bo,br,bm] "bdescr"      "free"
  ,offset [bo,br,bm] "bdescr"      "blocks"
  ,offset [co,cr,cm] "bdescr"      "gen_no"
  ,offset [co,cr,cm] "bdescr"      "link"

  ,size   [Cmm]      "generation"
  ,offset [co,cr,cm] "generation"  "n_new_large_words"
  ,offset [co,cr,cm] "generation"  "weak_ptr_list"

  ,size   both       "CostCentreStack"
  ,offset [co,cr,cm] "CostCentreStack"    "ccsID"
  ,offset [bo,br,cm] "CostCentreStack"    "mem_alloc"
  ,offset [bo,br,cm] "CostCentreStack"    "scc_count"
  ,offset [co,cr,cm] "CostCentreStack"    "prevStack"

  ,offset [co,cr,cm] "CostCentre"         "ccID"
  ,offset [co,cr,cm] "CostCentre"         "link"

  ,offset [bo,br,cm] "StgEntCounter"      "allocs"
  ,offset [bo,br,cm] "StgEntCounter"      "allocd"
  ,offset [bo,br,cm] "StgEntCounter"      "registeredp"
  ,offset [bo,br,cm] "StgEntCounter"      "link"
  ,offset [bo,br,cm] "StgEntCounter"      "entry_count"

  ,offset_ [co,cr,cm] "RTS_FLAGS" "ProfFlags.showCCSOnException"
                         "RtsFlags_ProfFlags_showCCSOnException"
  ,offset_ [co,cr,cm] "RTS_FLAGS" "DebugFlags.apply"
                         "RtsFlags_DebugFlags_apply"
  ,offset_ [co,cr,cm] "RTS_FLAGS" "DebugFlags.sanity"
                         "RtsFlags_DebugFlags_sanity"
  ,offset_ [co,cr,cm] "RTS_FLAGS" "DebugFlags.weak"
                         "RtsFlags_DebugFlags_weak"
  ,offset_ [co,cr,cm] "RTS_FLAGS" "GcFlags.initialStkSize"
                         "RtsFlags_GcFlags_initialStkSize"
  ,offset_ [co,cr,cm] "RTS_FLAGS" "MiscFlags.tickInterval"
                         "RtsFlags_MiscFlags_tickInterval"

  ,offset  [co,cr,cm] "StgLargeBitmap" "size"
  ,offset  [co]       "StgLargeBitmap" "bitmap"

  ,size   [Cmm]      "snEntry"
  ,offset [co,cr,cm] "snEntry" "sn_obj"
  ,offset [co,cr,cm] "snEntry" "addr"

  ,size   [Cmm]      "spEntry"
  ,offset [co,cr,cm] "spEntry" "addr"

   -- Note that this conditional part only affects the C headers.
   -- That's important, as it means we get the same PlatformConstants
   -- type on all platforms.
  ,if os == "mingw32"
   then concat
     [size [Cmm]        "StgAsyncIOResult"
     ,offset [co,cr,cm] "StgAsyncIOResult" "reqID"
     ,offset [co,cr,cm] "StgAsyncIOResult" "len"
     ,offset [co,cr,cm] "StgAsyncIOResult" "errCode"
     ]
   else []

        -- pre-compiled thunk types
  ,[mkWord [Haskell] "MAX_SPEC_SELECTEE_SIZE" "MAX_SPEC_SELECTEE_SIZE"]
  ,[mkWord [Haskell] "MAX_SPEC_AP_SIZE"       "MAX_SPEC_AP_SIZE"]

   -- closure sizes: these do NOT include the header (see below for
   -- header sizes)
  ,[mkWord [Haskell] "MIN_PAYLOAD_SIZE" "MIN_PAYLOAD_SIZE"]

  ,[mkInt  [Haskell] "MIN_INTLIKE" "MIN_INTLIKE"]
  ,[mkWord [Haskell] "MAX_INTLIKE" "MAX_INTLIKE"]

  ,[mkWord [Haskell] "MIN_CHARLIKE" "MIN_CHARLIKE"]
  ,[mkWord [Haskell] "MAX_CHARLIKE" "MAX_CHARLIKE"]

  ,[mkWord [Haskell] "MUT_ARR_PTRS_CARD_BITS" "MUT_ARR_PTRS_CARD_BITS"]

   -- A section of code-generator-related MAGIC CONSTANTS.
  ,[mkWord [Haskell] "MAX_Vanilla_REG"      "MAX_VANILLA_REG"]
  ,[mkWord [Haskell] "MAX_Float_REG"        "MAX_FLOAT_REG"]
  ,[mkWord [Haskell] "MAX_Double_REG"       "MAX_DOUBLE_REG"]
  ,[mkWord [Haskell] "MAX_Long_REG"         "MAX_LONG_REG"]
  ,[mkWord [Haskell] "MAX_XMM_REG"          "MAX_XMM_REG"]
  ,[mkWord [Haskell] "MAX_Real_Vanilla_REG" "MAX_REAL_VANILLA_REG"]
  ,[mkWord [Haskell] "MAX_Real_Float_REG"   "MAX_REAL_FLOAT_REG"]
  ,[mkWord [Haskell] "MAX_Real_Double_REG"  "MAX_REAL_DOUBLE_REG"]
  ,[mkWord [Haskell] "MAX_Real_XMM_REG"     "MAX_REAL_XMM_REG"]
  ,[mkWord [Haskell] "MAX_Real_Long_REG"    "MAX_REAL_LONG_REG"]

   -- This tells the native code generator the size of the spill
   -- area is has available.
  ,[mkWord [Haskell] "RESERVED_C_STACK_BYTES" "RESERVED_C_STACK_BYTES"]
   -- The amount of (Haskell) stack to leave free for saving
   -- registers when returning to the scheduler.
  ,[mkWord [Haskell] "RESERVED_STACK_WORDS" "RESERVED_STACK_WORDS"]
   -- Continuations that need more than this amount of stack
   -- should do their own stack check (see bug #1466).
  ,[mkWord [Haskell] "AP_STACK_SPLIM" "AP_STACK_SPLIM"]

   -- Size of a word, in bytes
  ,[mkWord [Haskell] "WORD_SIZE" "SIZEOF_HSWORD"]

   -- Size of a double in StgWords.
  ,[mkWord [Haskell] "DOUBLE_SIZE" "SIZEOF_DOUBLE"]

   -- Size of a C int, in bytes. May be smaller than wORD_SIZE.
  ,[mkWord [Haskell] "CINT_SIZE"       "SIZEOF_INT"]
  ,[mkWord [Haskell] "CLONG_SIZE"      "SIZEOF_LONG"]
  ,[mkWord [Haskell] "CLONG_LONG_SIZE" "SIZEOF_LONG_LONG"]

   -- Number of bits to shift a bitfield left by in an info table.
  ,[mkWord [Haskell] "BITMAP_BITS_SHIFT" "BITMAP_BITS_SHIFT"]

   -- Amount of pointer bits used for semi-tagging constructor closures
  ,[mkWord [Haskell] "TAG_BITS" "TAG_BITS"]

  ,[mkBool [Haskell] "WORDS_BIGENDIAN"    "defined(WORDS_BIGENDIAN)"]
  ,[mkBool [Haskell] "DYNAMIC_BY_DEFAULT" "defined(DYNAMIC_BY_DEFAULT)"]

  ,[mkWord [Haskell] "LDV_SHIFT"         "LDV_SHIFT"]
  ,[mkNat  [Haskell] "ILDV_CREATE_MASK"  "LDV_CREATE_MASK"]
  ,[mkNat  [Haskell] "ILDV_STATE_CREATE" "LDV_STATE_CREATE"]
  ,[mkNat  [Haskell] "ILDV_STATE_USE"    "LDV_STATE_USE"]
  ])
  ------------------------------
  -- Sensitive to [Profiling] --
  ------------------------------
  ++ map (mkSensitiveTo [Profiling]) (concat
  [sizeW    [Haskell]  "StgHeader"
  ,size     both       "StgHeader"

  ,whenDef Profiling $
    sizeW   both       "StgProfHeader"

  ,sizeW    [Haskell]  "StgThunkHeader"
  ,size     both       "StgThunkHeader"

  ,sizeW    [Haskell]  "StgClosure"
  ,offset   [bo,br,bm] "StgClosure"     "header.info"
  ,offset   [co,cmp]   "StgClosure"     "payload"
  ,whenDef Profiling $ concat
    [offset [bo,br,bm] "StgClosure"     "header.prof.ccs"
    ,offset [bo,br,bm] "StgClosure"     "header.prof.hp.ldvw"
    ]

  ,offset [co,cmp]   "StgThunk"       "payload"

  ,size   both    "StgUpdateFrame"
  ,size   [Cmm]   "StgCatchFrame"
  ,size   [Cmm]   "StgStopFrame"

  ,sizeW  [Haskell]  "StgSmallMutArrPtrs"
  ,size   both       "StgSmallMutArrPtrs"
  ,offset [bo,br,bm] "StgSmallMutArrPtrs" "ptrs"

  ,sizeW  [Haskell]  "StgMutArrPtrs"
  ,size   both       "StgMutArrPtrs"
  ,offset [bo,br,bm] "StgMutArrPtrs" "ptrs"
  ,offset [bo,br,bm] "StgMutArrPtrs" "size"

  ,sizeW  [Haskell]  "StgArrWords"
  ,size   both       "StgArrWords"
  ,offset [bo,cr,cm] "StgArrWords"   "bytes"
  ,offset [co,cmp]   "StgArrWords"   "payload"

  ,offset  [co,cr,cm] "StgTSO" "_link"
  ,offset  [co,cr,cm] "StgTSO" "global_link"
  ,offset  [co,cr,cm] "StgTSO" "what_next"
  ,offset  [co,cr,cm] "StgTSO" "why_blocked"
  ,offset  [co,cr,cm] "StgTSO" "block_info"
  ,offset  [co,cr,cm] "StgTSO" "blocked_exceptions"
  ,offset  [co,cr,cm] "StgTSO" "id"
  ,offset  [co,cr,cm] "StgTSO" "cap"
  ,offset  [co,cr,cm] "StgTSO" "saved_errno"
  ,offset  [co,cr,cm] "StgTSO" "trec"
  ,offset  [co,cr,cm] "StgTSO" "flags"
  ,offset  [co,cr,cm] "StgTSO" "dirty"
  ,offset  [co,cr,cm] "StgTSO" "bq"
  ,offset  [bo,br,bm] "StgTSO" "alloc_limit"
  ,whenDef Profiling $ concat
    [offset [bo,br,bm] "StgTSO" "header.prof.hp.ldvw"
    ,offset [bo,br,bm] "StgTSO" "prof.cccs"]
  ,offset  [bo,br,bm] "StgTSO" "stackobj"

  ,whenDef Profiling $
    size   [Cmm]      "StgTSOProfInfo"

  ,offset [bo,br,bm] "StgStack"    "sp"
  ,offset [bo]       "StgStack"    "stack"
  ,offset [co,cr,cm] "StgStack"    "stack_size"
  ,offset [co,cr,cm] "StgStack"    "dirty"

  ,offset [bo,br,bm] "StgUpdateFrame" "updatee"
  ,offset [co,cr,cm] "StgCatchFrame"  "handler"
  ,offset [co,cr,cm] "StgCatchFrame"  "exceptions_blocked"

  ,size   [Cmm]       "StgPAP"
  ,offset [co,cr,cm]  "StgPAP" "n_args"
  ,offset [co,crg,cm] "StgPAP" "fun"
  ,offset [co,cr,cm]  "StgPAP" "arity"
  ,offset [co,cmp]    "StgPAP" "payload"

  ,size   [Cmm]       "StgAP"
  ,offset [co,cr,cm]  "StgAP"  "n_args"
  ,offset [co,crg,cm] "StgAP"  "fun"
  ,offset [co,cmp]    "StgAP"  "payload"

  ,size   [Cmm]       "StgAP_STACK"
  ,offset [co,cr,cm]  "StgAP_STACK" "size"
  ,offset [co,crg,cm] "StgAP_STACK" "fun"
  ,offset [co,cmp]    "StgAP_STACK" "payload"

  ,size   [Cmm]       "StgSelector"

  ,offset [co,crg,cm] "StgInd" "indirectee"

  ,size   [Cmm]      "StgMutVar"
  ,offset [co,cr,cm] "StgMutVar" "var"

  ,size   [Cmm]      "StgAtomicallyFrame"
  ,offset [co,cr,cm] "StgAtomicallyFrame" "code"
  ,offset [co,cr,cm] "StgAtomicallyFrame" "next_invariant_to_check"
  ,offset [co,cr,cm] "StgAtomicallyFrame" "result"

  ,offset [co,cr,cm] "StgInvariantCheckQueue" "invariant"
  ,offset [co,cr,cm] "StgInvariantCheckQueue" "my_execution"
  ,offset [co,cr,cm] "StgInvariantCheckQueue" "next_queue_entry"

  ,offset [co,cr,cm] "StgAtomicInvariant" "code"

  ,offset [co,cr,cm] "StgTRecHeader" "enclosing_trec"

  ,size   [Cmm]      "StgCatchSTMFrame"
  ,offset [co,cr,cm] "StgCatchSTMFrame" "handler"
  ,offset [co,cr,cm] "StgCatchSTMFrame" "code"

  ,size   [Cmm]      "StgCatchRetryFrame"
  ,offset [co,cr,cm] "StgCatchRetryFrame" "running_alt_code"
  ,offset [co,cr,cm] "StgCatchRetryFrame" "first_code"
  ,offset [co,cr,cm] "StgCatchRetryFrame" "alt_code"

  ,offset [co,cr,cm] "StgTVarWatchQueue" "closure"
  ,offset [co,cr,cm] "StgTVarWatchQueue" "next_queue_entry"
  ,offset [co,cr,cm] "StgTVarWatchQueue" "prev_queue_entry"

  ,size   [Cmm]      "StgTVar"
  ,offset [co,cr,cm] "StgTVar" "current_value"
  ,offset [co,cr,cm] "StgTVar" "first_watch_queue_entry"
  ,offset [co,cr,cm] "StgTVar" "num_updates"

  ,size   [Cmm]      "StgWeak"
  ,offset [co,cr,cm] "StgWeak" "link"
  ,offset [co,cr,cm] "StgWeak" "key"
  ,offset [co,cr,cm] "StgWeak" "value"
  ,offset [co,cr,cm] "StgWeak" "finalizer"
  ,offset [co,cr,cm] "StgWeak" "cfinalizers"

  ,size   [Cmm]      "StgCFinalizerList"
  ,offset [co,cr,cm] "StgCFinalizerList" "link"
  ,offset [co,cr,cm] "StgCFinalizerList" "fptr"
  ,offset [co,cr,cm] "StgCFinalizerList" "ptr"
  ,offset [co,cr,cm] "StgCFinalizerList" "eptr"
  ,offset [co,cr,cm] "StgCFinalizerList" "flag"

  ,size   [Cmm]      "StgMVar"
  ,offset [co,cr,cm] "StgMVar" "head"
  ,offset [co,cr,cm] "StgMVar" "tail"
  ,offset [co,cr,cm] "StgMVar" "value"

  ,size   [Cmm]      "StgMVarTSOQueue"
  ,offset [co,cr,cm] "StgMVarTSOQueue" "link"
  ,offset [co,cr,cm] "StgMVarTSOQueue" "tso"

  ,size   [Cmm]      "StgBCO"
  ,offset [co,cr,cm] "StgBCO" "instrs"
  ,offset [co,cr,cm] "StgBCO" "literals"
  ,offset [co,cr,cm] "StgBCO" "ptrs"
  ,offset [co,cr,cm] "StgBCO" "arity"
  ,offset [co,cr,cm] "StgBCO" "size"
  ,offset [co,cmp]   "StgBCO" "bitmap"

  ,size   [Cmm]      "StgStableName"
  ,offset [co,cr,cm] "StgStableName" "sn"

  ,size   [Cmm]      "StgBlockingQueue"
  ,offset [co,cr,cm] "StgBlockingQueue" "bh"
  ,offset [co,cr,cm] "StgBlockingQueue" "owner"
  ,offset [co,cr,cm] "StgBlockingQueue" "queue"
  ,offset [co,cr,cm] "StgBlockingQueue" "link"

  ,size   [Cmm]      "MessageBlackHole"
  ,offset [co,cr,cm] "MessageBlackHole" "link"
  ,offset [co,cr,cm] "MessageBlackHole" "tso"
  ,offset [co,cr,cm] "MessageBlackHole" "bh"
  ])

  -----------------------------------------------
  -- Sensitive to [Profiling,TablesNextToCode] --
  -----------------------------------------------
  ++ map (mkSensitiveTo [Profiling,TablesNextToCode]) (concat
  [size [Haskell] "StgRetInfoTable"
  ,size   both    "StgInfoTable"
  ,whenNotDef TablesNextToCode $
    offset [bro "CODE_OR_ENTRY",br]    "StgInfoTable" "entry"
  ,offset  [bro "CODE_OR_ENTRY",br,bm] "StgInfoTable" "layout.payload.ptrs"
  ,offset  [bro "CODE_OR_ENTRY",br,bm] "StgInfoTable" "layout.payload.nptrs"
  ,offset  [bro "CODE_OR_ENTRY",br,bm] "StgInfoTable" "type"
  ,offset  [bro "CODE_OR_ENTRY",br,bm] "StgInfoTable" "u.constr_tag"

  -- CODE_OR_ENTRY= code      if TABLES_NEXT_TO_CODE
  --                entry     if !TABLES_NEXT_TO_CODE
  -- See [Note StgFunInfoTable/StgInfoTable] to see what's going on here

  ,whenDef TablesNextToCode $
    offset [cro "i.CODE_OR_ENTRY",cr,cm] "StgFunInfoTable" "f.slow_apply_offset"
  ,whenNotDef TablesNextToCode $
    offset [cro "i.CODE_OR_ENTRY",cr]    "StgFunInfoTable" "f.slow_apply"
  ,offset  [cro "i.CODE_OR_ENTRY",cr,cm] "StgFunInfoTable" "f.fun_type"
  ,offset  [bro "i.CODE_OR_ENTRY",br,bm] "StgFunInfoTable" "f.arity"
  ,offset  [cro "i.CODE_OR_ENTRY",cr,cm] "StgFunInfoTable" "f.b.bitmap"
  ])
     ++ map (mkSensitiveTo []) (concat
  [lit [Cmm] "StgFunInfoTable_slow_apply"
    ["#ifdef TABLES_NEXT_TO_CODE"
    ,def "StgInfoTable_entry(ptr)" "(ptr)"
    ,def "StgFunInfoTable_slow_apply(ptr)"
      "(TO_W_(StgFunInfoTable_slow_apply_offset(ptr)) + StgInfoTable_entry(ptr))"
    ,"#else"
    ,mkMacro "StgInfoTable_entry"
    ,mkMacro "StgFunInfoTable_slow_apply"
    ,"#endif"
    ]
  ,lit [Haskell] "lOAD_StgInfoTable_entry"
     ["lOAD_StgInfoTable_entry :: DynFlags -> CmmExpr -> CmmExpr"
     ,"lOAD_StgInfoTable_entry dflags ptr"
     ,"  | tablesNextToCode dflags = ptr"
     ,"  | otherwise = " ++ mkLoad "StgInfoTable_entry"
     ]

-- [Note StgFunInfoTable/StgInfoTable]
-------------------------------------------------------------------------
-- When TABLES_NEXT_TO_CODE                                            --
--                                                                     --
-- StgClosure:                                                         --
-- +-------------+------------    ----+                                --
-- | header.info | payload            |                                --
-- +-------------+------------    ----+                                --
--      |                                                              --
--      |  StgFunInfoTable                                             --
--      |  +------------------------+                                  --
--      |  | f.slow_apply_offset    |-----+ offset from i.code         --
--      |  +------------------------+     |                            --
--      |  | f.b                    |--+  | offset from i.code         --
--      |  +------------------------+  |  |                            --
--      |  | f.fun_type             |  |  |                            --
--      |  +------------------------+  |  |                            --
--      |  | f.arity                |  |  |                            --
--      |  + =======================+  |  |                            --
--      |  | i.layout.payload.ptrs  |  |  |                            --
--      |  +------------------------+  |  |                            --
--      |  | i.layout.payload.nptrs |  |  |                            --
--      |  +------------------------+  |  |                            --
--      |  | i.type                 |  |  |                            --
--      |  +------------------------+  |  |                            --
--      |  | i.u.constr_tag         |  |  |                            --
--      +->+------------------------+  |  |                            --
--         | i.code                 |  |  |                            --
--                                     |  |                            --
--                                  <--+  |                            --
--                                        |                            --
--                                  <-----+                            --
--                                                                     --
--         |                        |                                  --
--         +------------------------+                                  --
-------------------------------------------------------------------------

-------------------------------------------------------------------------
-- When !TABLES_NEXT_TO_CODE                                           --
--                                                                     --
-- StgClosure:                                                         --
-- +-------------+------------    ----+                                --
-- | header.info | payload            |                                --
-- +-------------+------------    ----+                                --
--      |                                                              --
--      |  StgFunInfoTable                                             --
--      +->+------------------------+                                  --
--         | i.entry                |-----> +---------+                --
--         +------------------------+       |  code   |                --
--         | i.layout.payload.ptrs  |                                  --
--         +------------------------+  +---->                          --
--         | i.layout.payload.nptrs |  |                               --
--         +------------------------+  |    |         |                --
--         | i.type                 |  |    +---------+                --
--         +------------------------+  |                               --
--         | i.u.constr_tag         |  |                               --
--         + =======================+  |                               --
--         | f.fun_type             |  |                               --
--         +------------------------+  |                               --
--         | f.arity                |  |                               --
--         +------------------------+  |                               --
--         | f.srt                  |  |                               --
--         +------------------------+  |                               --
--         | f.b.bitmap             |  |                               --
--         +------------------------+  |                               --
--         | f.slow_apply           |--+                               --
--         +------------------------+                                  --
-------------------------------------------------------------------------

  ])
  where
    whenDef d = map (\c -> c{cErrorWhen=f (not . (Set.member d))})
    whenNotDef d = map (\c -> c{cErrorWhen=f (Set.member d)})
    f p = [set|set<-subSets allDefines, p set]
    mkSensitiveTo ds c = c{cSensitiveTo = Set.fromList ds}
    both = [Haskell, Cmm]
    bo  = mkOffset_       both
--  ho  = mkOffset_       [Haskell] --Not currently used. Uncomment if needed
    co  = mkOffset_       [Cmm]
    bro = mkRelOffset_    both
--  hro = mkRelOffset_    [Haskell] --Not currently used. Uncomment if needed
    cro = mkRelOffset_    [Cmm]
    br  = mkRep_          both
--  hr  = mkRep_          [Haskell] --Not currently used. Uncomment if needed
    cr  = mkRep_          [Cmm]
    bm  = mkMacro_        both
--  hm  = mkMacro_        [Haskell] --Not currently used. Uncomment if needed
    cm  = mkMacro_        [Cmm]
    cmp = mkMacroPayload_ [Cmm]
    crg = mkRepGcptr_     [Cmm]

data Constant   = Constant {
   cName        :: String
  ,cSensitiveTo :: Set Define
  ,cErrorWhen   :: [Set Define]
  ,cTargets     :: [Target]
  ,cEither      :: Either Independant Dependant
}

--Platform Independant Constant
data Independant = Macro | MacroPayload | RepGcptr | Literal [String]

--Platform Dependant Constant
data Dependant = Rep  CExpr -- note [Rep]
               | Word CExpr
               | Int  CExpr
               | Nat  CExpr
               | Bool CPPExpr

-- [Rep]
-- Rep is like Word, except it represents the size in bytes of a field.
-- It has a different format in Cmm land vs Haskell land:
--   Cmm land: b32         (32 bits)
--   Haskell land: 4       (4 bytes)

showType :: Dependant -> String
showType Rep{}  = "Int"
showType Word{} = "Int"
showType Int{}  = "Int"
showType Nat{}  = "Integer"
showType Bool{} = "Bool"

newtype CExpr = CExpr     String
newtype CPPExpr = CPPExpr String
data Target = Haskell | Cmm deriving Eq

----------------------------------------------------------------------
-- [Add sensitivity]                                                --
-- To add sensitivity to a new CPP Define, modify the:              --
--   * Define data type                                             --
--   * allDefines function                                          --
--   * showDefine function                                          --
----------------------------------------------------------------------

data Define = Profiling | TablesNextToCode deriving (Eq, Show, Ord)

allDefines :: Set Define
allDefines = Set.fromList [Profiling, TablesNextToCode]

showDefine :: Target -> Define -> String
showDefine Cmm     Profiling = "PROFILING"
showDefine Cmm     TablesNextToCode = "TABLES_NEXT_TO_CODE"
showDefine Haskell Profiling = "(gopt Opt_SccProfilingOn dflags)"
showDefine Haskell TablesNextToCode = "(tablesNextToCode dflags)"

size,sizeW :: [Target] -> String -> [Constant]
size ts theType = [mkWord ts name expr]
  where
    name = "SIZEOF_"    ++ theType
    expr = "TYPE_SIZE(" ++ theType ++ ")"

sizeW ts theType = [mkWord ts name expr]
  where
    name = "SIZEOFW_"    ++ theType
    expr = "TYPE_SIZEW(" ++ theType ++ ")"

lit :: [Target] -> String -> [String] -> [Constant]
lit ts nm strs  = [mkConstant ts nm $ Left $ Literal strs]

mkOffset_,mkRep_,mkMacro_, mkMacroPayload_, mkRepGcptr_
             :: [Target]           -> String -> String -> String -> Constant
mkRelOffset_ :: [Target] -> String -> String -> String -> String -> Constant
mkRelOffset_ ts fld' typ fld nameBase = mkConstant ts n $ Right $ Int $ CExpr e
  where
    n = "OFFSET_" ++ nameBase
    e =   "(offsetof(" ++ typ ++ "," ++ fld  ++ "))"
     ++ "- (offsetof(" ++ typ ++ "," ++ fld' ++ "))"
mkOffset_ ts typ fld nameBase = mkConstant ts name $ Right $  Word $ CExpr expr
  where
    name = "OFFSET_" ++ nameBase
    expr = "offsetof(" ++ typ ++ "," ++ fld ++ ")"
mkRep_ ts typ fld nameBase = mkConstant ts name $ Right $ Rep $ CExpr expr
  where
    name = "REP_" ++ nameBase
    expr = "FIELD_SIZE(" ++ typ ++ ", " ++ fld ++ ")"

mkWord,mkInt,mkNat,mkBool :: [Target] -> String -> String -> Constant
mkWord ts n e = mkConstant ts n $ Right $ Word $ CExpr e
mkInt  ts n e = mkConstant ts n $ Right $ Int  $ CExpr e
mkNat  ts n e = mkConstant ts n $ Right $ Nat  $ CExpr e
mkBool ts n e = mkConstant ts n $ Right $ Bool $ CPPExpr e

mkMacro_        ts _ty _fld nm = mkConstant ts nm $ Left Macro
mkMacroPayload_ ts _ty _fld nm = mkConstant ts nm $ Left MacroPayload
mkRepGcptr_     ts _ty _fld nm = mkConstant ts nm $ Left RepGcptr

mkConstant :: [Target] -> String -> Either Independant Dependant ->  Constant
mkConstant targets name e = Constant {cName = name,
                                      cSensitiveTo = undefined,
                                      cErrorWhen = [],
                                      cTargets = targets,
                                      cEither = e}

offset_ :: [String->String->String->Constant]->String->String->String->[Constant]
offset  :: [String->String->String->Constant]->String->String->        [Constant]
offset_ fs theType theField nameBase = [f theType theField nameBase | f <- fs]
offset  fs theType theField          = offset_ fs theType theField nameBase
  where nameBase = theType ++ "_" ++ (deleteDots $ theField)

subSets :: Ord a => Set a -> [Set a]
subSets = map Set.fromList . subsequences . Set.elems

getResultMap :: IO (Map (String,Set Define) Integer)
getResultMap = do
  results <- mapM doSet $ subSets allDefines
  let m = Map.fromList $ catMaybes $ concat results
  return m
 where
  prefix = "derivedConstant"
  doSet set = do
    tmpdir   <- requireOption "tmpdir"       o_tmpdir
    gccProg  <- requireOption "gcc program"  o_gccProg
    nmProg   <- requireOption "nm program"   o_nmProg
    verbose  <- getOption                    o_verbose
    gccFlags <- getOption                    o_gccFlags
    let cFile = tmpdir </> "tmp" ++ concatMap show (Set.elems set) ++ ".c"
        oFile = tmpdir </> "tmp" ++ concatMap show (Set.elems set) ++ ".o"
        gccFlags' = gccFlags ++ ["-c", cFile, "-o", oFile]
    -- Note [undef TABLES_NEXT_TO_CODE]
    -- ghcautconf.h might #define TABLES_NEXT_TO_CODE.
    -- However, we need to generate values with TABLES_NEXT_TO_CODE on and off.
    -- So we undefine it. It might be redefined on the line bellow it.
    writeFile cFile $ unlines $
      ["//autogenerated file see DeriveConstants.hs"
      ,"#define IN_STG_CODE 0"
      ,"#define THREADED_RTS"
      ,"#include \"ghcautoconf.h\""     -- Note
      ,"#undef TABLES_NEXT_TO_CODE" -- [undef TABLES_NEXT_TO_CODE]
      , unlines $ map (("#define " ++) . showDefine Cmm) $ Set.elems set
      ,"#include \"PosixSource.h\""
      ,"#include \"Rts.h\""
      ,"#include \"Stable.h\""
      ,"#include \"Capability.h\""
      ,""
      ,"#include <inttypes.h>"
      ,"#include <stddef.h>"
      ,"#include <stdio.h>"
      ,"#include <string.h>"
      ,""
      ,"#ifdef TABLES_NEXT_TO_CODE"
      ,"#  define CODE_OR_ENTRY code"
      ,"#else"
      ,"#  define CODE_OR_ENTRY entry"
      ,"#endif"
      ,""
      ,"#define TYPE_SIZE(type) (sizeof(type))"
      ,"#define TYPE_SIZEW(type) (sizeofW(type))"
      ,"#define FIELD_SIZE(s_type, field) \\"
      ,"((size_t)sizeof(((s_type*)0)->field))"
      ,""
      ,"#pragma GCC poison sizeof sizeofw"

      ] ++ concatMap (doConstant set) constants
    execute verbose gccProg $ gccFlags'
    xs <- readProcess nmProg ["-P",oFile] ""
    return $ map (parseNmLine set) $ lines xs

  -- We add 1 to the value, as some platforms will make a symbol
  -- of size 1 when for
  --     char foo[0];
  -- We then subtract 1 again when parsing.
  doConstant set c | set `elem` cErrorWhen c = []
                   | otherwise = case cEither c of
                       Left{} -> []
                       Right e -> doExpr (prefix ++ cName c) e

  doExpr n (Rep  (CExpr cExpr))
    = ["char " ++ n ++ "[1 + " ++ cExpr ++ "];"]
  doExpr n (Word (CExpr cExpr))
    = ["char " ++ n ++ "[1 + " ++ cExpr ++ "];"]
  doExpr n (Int  (CExpr cExpr))
    = ["char " ++ n ++ "Mag[1 + ((intptr_t)(" ++ cExpr ++ ") >= 0 ? ("
       ++ cExpr ++ ") : -(" ++ cExpr ++ "))];"
      ,"char " ++ n ++ "Sig[(intptr_t)(" ++ cExpr ++ ") >= 0 ? 3 : 1];"
      ]
  doExpr n (Nat  (CExpr cExpr))
    = -- These casts fix "right shift count >= width of type"
            -- warnings
    let cExpr' = "(uint64_t)(size_t)(" ++ cExpr ++ ")"
    in ["char " ++ n ++ "0[1 + ((" ++ cExpr' ++ ") & 0xFFFF)];"
       ,"char " ++ n ++ "1[1 + (((" ++ cExpr' ++ ") >> 16) & 0xFFFF)];"
       ,"char " ++ n ++ "2[1 + (((" ++ cExpr' ++ ") >> 32) & 0xFFFF)];"
       ,"char " ++ n ++ "3[1 + (((" ++ cExpr' ++ ") >> 48) & 0xFFFF)];"
       ]
  doExpr n (Bool (CPPExpr cppExpr))
    = ["#if " ++ cppExpr,
       "char " ++ n ++ "[1];",
       "#else",
       "char " ++ n ++ "[2];",
       "#endif"]

  -- parseNmLine parses "nm -P" output that looks like
  -- "derivedConstantMAX_Vanilla_REG C 0000000b 0000000b" (GNU nm)
  -- "_derivedConstantMAX_Vanilla_REG C b 0" (Mac OS X)
  -- "_derivedConstantMAX_Vanilla_REG C 000000b" (MinGW)
  -- "derivedConstantMAX_Vanilla_REG D        1        b" (Solaris)
  -- and returns ("MAX_Vanilla_REG", 11)
  parseNmLine line
    = case words line of
      ('_' : n) : "C" : s : _ -> mkP n s
      n : "C" : s : _ -> mkP n s
      [n, "D", _, s] -> mkP n s
      _ -> Nothing
        where mkP r s = case (stripPrefix prefix r, readHex s) of
                (Just name, [(size, "")]) -> Just (name, size)
                _ -> Nothing
sanityCheck :: Map (String,Set Define) Integer ->  Target -> Bool
sanityCheck m t = all f constants
 where
  f c = case allEq $ relResults c of
          True -> True
          False -> error
           ("sanityCheck: " ++ show (cName c) ++ " " ++ show (relResults c))

  relResults :: Constant -> [String]
  relResults c = case cEither c of
    Left{} -> []
    Right{} -> map (lookupConstant m t c) $ relDefines c
  relDefines :: Constant -> [Set Define]
  relDefines c = (filter (Set.isSubsetOf $ cSensitiveTo c) $ subSets allDefines)
                  \\ cErrorWhen c

  allEq :: Eq a => [a] -> Bool
  allEq [] = True
  allEq xs = all (== (head xs)) xs

lookupConstant :: Map (String,Set Define) Integer
               -> Target -> Constant -> Set Define -> String
lookupConstant m t c set = case cEither c of
  Left{} -> error "attempted to look up the value of an independant"
  Right e -> case e of
   Word{}  -> show $ lookupSmall (cName c,set) - 1
   Rep{}   -> case t of Haskell -> show $ lookupSmall (cName c,set) - 1
                        Cmm   -> "b" ++ show ((lookupSmall (cName c,set) - 1)*8)
   Int{}   -> show $ (lookupSmall (cName c ++ "Mag",set) - 1)
                   * (lookupSmall (cName c ++ "Sig",set) - 2)
   Nat{}   -> show $   (lookupSmall (cName c ++ "0",set) - 1)
              + shiftL (lookupSmall (cName c ++ "1",set) - 1) 16
              + shiftL (lookupSmall (cName c ++ "2",set) - 1) 32
              + shiftL (lookupSmall (cName c ++ "3",set) - 1) 48
   Bool{}-> case lookupSmall (cName c,set) of 1 -> case t of Haskell -> "True"
                                                             Cmm     -> "1"
                                              2 -> case t of Haskell -> "False"
                                                             Cmm     -> "0"
                                              n -> error ("Bad bool: " ++ show n)
  where
    -- Note [Int Bounds]
    -- If an Int value is larger than 2^28 or smaller than -2^28, then fail.
    -- This test is a bit conservative, but if any constants are roughly
    -- maxBound or minBound then we probably need them to be Integer rather than
    -- Int so that cross-compiling between 32bit and 64bit platforms works.
    lookupSmall :: (String,Set Define) -> Integer
    lookupSmall x =
      case  Map.lookup x m of
        Just v -> if v >   2^(28 :: Int) || -- Note [Int Bounds]
                     v < -(2^(28 :: Int))
                  then error ("Value too large for GetWord: " ++ show v) else v
        _ -> error (show x ++ " not found (lookupSmall)")

filterConstants :: Target -> [Constant]
filterConstants t = [c | c <- constants, t `elem` cTargets c]

writeHaskellType :: IO ()
writeHaskellType = do
 outFile <- requireOption "no output file" o_outputFile
 writeFile outFile $ unlines
  ["data PlatformConstants = PlatformConstants {"
  ,unlines $ indent 2 $ commas $ concatMap doConstant $ filterConstants Haskell
  ,"} deriving Read"
  ]
 where
   doConstant c = concatMap (doSet c) $ subSets $ cSensitiveTo c
   doSet c set = if set `elem` cErrorWhen c then [] else case cEither c of
     Left{} -> []
     Right e -> ["pc" ++ concatMap show (Set.elems set)
                ++ "_" ++ cName c ++ " :: " ++ showType e]

dflagsOrCodeGenConstants :: IO [Constant]
dflagsOrCodeGenConstants = do
 whr <- requireOption "needs --dflags or --codegen" o_where
 let p c = case whr of CodeGen -> either (\_->True) (\_->False) (cEither c)
                       Dflags -> either (\_->False) (\_->True) (cEither c)
 return $ filter p $ filterConstants Haskell

mkLoad,mkStore,mkMacro :: String -> String
mkLoad nm =  "CmmLoad (cmmOffsetB dflags ptr (oFFSET_" ++ nm ++
             " dflags)) $ cmmBits $ widthFromBytes $ rEP_" ++ nm ++ " dflags"
mkStore nm = "mkStore (cmmOffsetB dflags ptr (oFFSET_" ++ nm ++ " dflags)) val"
mkMacro nm = def (nm ++ "(__ptr__)")
                 ("REP_" ++ nm ++ "[__ptr__+OFFSET_" ++ nm ++ "]")

writeHaskellWrappers :: IO ()
writeHaskellWrappers = do
 outFile <- requireOption "no output file" o_outputFile
 cs <- dflagsOrCodeGenConstants
 writeFile outFile $ unlines $ concatMap doConstant cs
 where
   doConstant :: Constant -> [String]
   doConstant c = case cEither c of
     Left Macro ->
      ["lOAD_" ++ cName c ++ " :: DynFlags -> CmmExpr -> CmmExpr"
      ,"lOAD_" ++ cName c ++ " dflags ptr = " ++ mkLoad (cName c)
      ,"sTORE_" ++ cName c ++ " :: DynFlags -> CmmExpr -> CmmExpr -> CmmAGraph"
      ,"sTORE_" ++ cName c ++ " dflags ptr val = " ++ mkStore (cName c)]
     Left (Literal strs) -> strs
     Left{} -> error "writeHaskellWrappers"
     Right e -> [haskellise (cName c) ++ " :: DynFlags -> " ++ showType e
                ,haskellise (cName c) ++ " dflags = "]
      ++ (indent 2 $ f c (Set.empty) (Set.elems $ cSensitiveTo c))
   f :: Constant -> Set Define -> [Define] -> [String]
   f c set [] = if set `elem` cErrorWhen c then [mkError Haskell set c]
                else ["pc" ++ concatMap show (Set.elems set) ++ "_" ++ cName c
                      ++ " $ sPlatformConstants $ settings dflags"]
   f c set (d:ds) = concat [["if " ++ showDefine Haskell d ++ " then ("]
                            ,indent 2 $ f c (Set.insert d set) ds
                            ,[") else ("]
                            ,indent 2 $ f c set ds
                            ,[")"]
                            ]

writeHaskellExports :: IO ()
writeHaskellExports = do
 outFile <- requireOption "no output file" o_outputFile
 cs <- dflagsOrCodeGenConstants
 writeFile outFile $ unlines $ indent 4 $ commas $ concatMap doConstant cs
 where
  doConstant c = case cEither c of Left Macro -> ["lOAD_" ++ cName c
                                                 ,"sTORE_" ++ cName c]
                                   Left Literal{} -> [cName c]
                                   Left{} -> error  "writeHaskellExports"
                                   Right{} -> [haskellise $ cName c]

mkError :: Target -> Set Define -> Constant -> String
mkError t set c = case t of
  Cmm -> "#error " ++ msg
  Haskell -> "error \"" ++ msg ++ "\""
  where msg = "Derived Constant " ++ cName c ++ " is not defined for "
           ++ "the following sets of CPP defines: " ++ show (cErrorWhen c) ++ ". "
           ++ "The current set of CPP defines is: " ++ show set ++ "."

writeValues :: Target -> IO ()
writeValues Haskell = do
 outFile <- requireOption "no output file" o_outputFile
 resMap <- getResultMap
 case sanityCheck resMap Haskell of True -> return () -- do a sanitycheck
                                    False -> error "sanityCheck is buggy"
 let doConstant :: Constant -> [String]
     doConstant c = case cEither c of
       Left{} -> []
       Right{} -> concatMap doSet $ subSets $ cSensitiveTo c
      where
       doSet :: Set Define -> [String]
       doSet set = if set `elem` cErrorWhen c then [] else
         ["pc" ++ concatMap show (Set.elems set) ++ "_" ++ cName c ++ " = "
          ++ lookupConstant resMap Haskell c set]

 writeFile outFile $ unlines
   ["PlatformConstants {"
   ,unlines $ indent 2 $ commas $ concatMap doConstant $ filterConstants Haskell
   ,"}"
   ]

writeValues Cmm = do
  outFile  <- requireOption "no output file" o_outputFile
  resMap <- getResultMap
  case sanityCheck resMap Cmm of True -> return () -- do a sanitycheck
                                 False -> error "sanityCheck is buggy"
  let f :: Set Define -> [String]
      f set = g Set.empty (Set.elems set)
                $ filter ((== set).cSensitiveTo) $ filterConstants Cmm
      g :: Set Define -> [Define] -> [Constant] -> [String]
      g set [] cs = concatMap (doConstant set) cs
      g set (d:ds) cs = concat [["#ifdef " ++ showDefine Cmm d]
                               ,indent 2 $ g (Set.insert d set) ds cs
                               ,["#else /* " ++ showDefine Cmm d ++ " */"]
                               ,indent 2 $ g set ds cs
                               ,["#endif /* !" ++ showDefine Cmm d ++ " */"]
                               ]
      doConstant :: Set Define -> Constant -> [String]
      doConstant set c =
       case cEither c of
        Right{} -> [def (cName c) $ if set `elem` cErrorWhen c
         then mkError Cmm set c else lookupConstant resMap Cmm c set]
        Left typ -> case typ of
          Literal strs -> strs
          RepGcptr -> [def ("REP_" ++ cName c) " gcptr"]
          Macro    -> [mkMacro (cName c)]
          MacroPayload ->  [def x y]
           where x = cName c ++ "(__ptr__,__ix__)"
                 y = "W_[__ptr__ + OFFSET_" ++ cName c ++ " + WDS(__ix__)]"

  writeFile outFile $ unlines $
    ["/* This file is created automatically.  Do not edit by hand.*/"
    ,unlines $ concatMap f $ subSets allDefines
    ]

die :: String -> IO a
die err = do hPutStrLn stderr err
             exitFailure

execute :: Bool -> FilePath -> [String] -> IO ()
execute verbose prog args
 = do when verbose $ putStrLn $ showCommandForUser prog args
      ec <- rawSystem prog args
      unless (ec == ExitSuccess) $
          die ("Executing " ++ show prog ++ " failed")

main :: IO ()
main = do
  mode <- requireOption "mode" o_mode
  case mode of
    Gen_Haskell_Wrappers -> writeHaskellWrappers
    Gen_Haskell_Exports  -> writeHaskellExports
    Gen_Haskell_Type     -> writeHaskellType
    Gen_Values target    -> writeValues target

requireOption :: String -> (Options -> Maybe a) -> IO a
requireOption descr opt = do
  opts <- parseArgs
  case opt opts of
    Just x  -> return x
    Nothing -> die ("No " ++ descr ++ " given")

getOption :: (Options -> a) -> IO a
getOption opt = do
  opts <- parseArgs
  return $ opt opts

data Options = Options {
                   o_verbose :: Bool,
                   o_mode :: Maybe Mode,
                   o_where :: Maybe Where,
                   o_tmpdir :: Maybe FilePath,
                   o_outputFile :: Maybe FilePath,
                   o_gccProg :: Maybe FilePath,
                   o_gccFlags :: [String],
                   o_nmProg :: Maybe FilePath
}

parseArgs :: IO Options
parseArgs = do args <- getArgs
               opts <- f emptyOptions args
               return (opts {o_gccFlags = reverse (o_gccFlags opts)})
 where
  f opts [] = return opts
  f opts ("-v" : args')                  =       f (opts {o_verbose = True}) args'
  f opts ("--codegen" : args')           = f (opts {o_where = Just CodeGen}) args'
  f opts ("--dflags" : args')            =  f (opts {o_where = Just Dflags}) args'
  f opts ("--tmpdir" : dir : args')      =    f (opts {o_tmpdir = Just dir}) args'
  f opts ("-o" : fn : args')             = f (opts {o_outputFile = Just fn}) args'
  f opts ("--nm-program" : prog : args') =   f (opts {o_nmProg = Just prog}) args'
  f opts ("--gcc-program" : prog : args') = f (opts {o_gccProg = Just prog}) args'
  f opts ("--gcc-flag" : flag : args')   =
    f (opts {o_gccFlags = flag : o_gccFlags opts}) args'
  f opts ("--gen-haskell-type" : args')  =
    f (opts {o_mode = Just Gen_Haskell_Type}) args'
  f opts ("--gen-haskell-wrappers" : args') =
    f (opts {o_mode = Just Gen_Haskell_Wrappers}) args'
  f opts ("--gen-haskell-exports" : args') =
    f (opts {o_mode = Just Gen_Haskell_Exports}) args'
  f opts ("--gen-header" : args')        =
    f (opts {o_mode = Just (Gen_Values Cmm)}) args'
  f opts ("--gen-haskell-value" : args') =
    f (opts {o_mode = Just (Gen_Values Haskell)}) args'
  f _ (flag : _) = die ("Unrecognised flag: " ++ show flag)

  emptyOptions = Options {
    o_verbose = False,
    o_mode = Nothing,
    o_where = Nothing,
    o_tmpdir = Nothing,
    o_outputFile = Nothing,
    o_gccProg = Nothing,
    o_gccFlags = [],
    o_nmProg = Nothing
  }

data Mode = Gen_Haskell_Type
          | Gen_Haskell_Wrappers
          | Gen_Haskell_Exports
          | Gen_Values Target

data Where = Dflags | CodeGen
--------------------------------
-- Boring string manipulation --
--------------------------------

-- deleteDots "abcd.defg.hijk" = "hijk"
deleteDots :: String -> String
deleteDots = reverse . f . reverse
 where
  f [] = []
  f ('.':_) = []
  f (x:xs) = x : f xs

haskellise :: String -> String
haskellise (c : cs) = toLower c : cs
haskellise "" = ""

indent :: Int -> [String] -> [String]
indent n xs = map ((take n $ repeat ' ')++) xs

commas :: [String] -> [String]
commas   xs =  (' ' :    head xs)
        : (map (',' :) $ tail xs)

def :: String -> String -> String
def x y = "#define" ++ " " ++ x ++ " " ++ y
